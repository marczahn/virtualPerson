# Project Research Summary

**Project:** VirtualPerson V2 — Motivation-Driven Consciousness Simulation
**Domain:** Hybrid LLM-code agent simulation (Go, stateful person with drives and biological degradation)
**Researched:** 2026-02-18
**Confidence:** HIGH (stack and architecture), HIGH (features — grounded in V1 retrospective), MEDIUM (novel hybrid pitfalls)

## Executive Summary

VirtualPerson V2 is a Go application simulating a human being whose internal experience is generated by a large language model, but whose motivational pressure is computed deterministically by code. V1 proved the four-layer pipeline (Sense → Biology → Psychology → Consciousness) was architecturally sound but behaviorally hollow: the person described emotions without being driven by them, and an over-tuned homeostasis system prevented any urgency from accumulating. The central design thesis for V2 is that aliveness requires code-computed drives that create real biological pressure — pressure the LLM must interpret rather than invent. This means the motivation layer is the new structural core of V2, sitting between biology and consciousness, and every feature decision flows from it.

The recommended approach is a slim rebuild in a new `v2/` directory: retain the Go/SQLite/Anthropic-SDK stack (with minor version bumps), reduce the 20-variable biological model to 8–10 motivationally-relevant variables, and insert a new `motivation` package between `biology` and `consciousness`. The motivation package is a pure-function processor — stateless, fully testable without an LLM — that takes bio state and personality and returns drive urgencies, an active goal, and action candidates. The consciousness layer receives these as phenomenological descriptions, never as raw numbers. Three new tag types in the LLM output protocol ([ACTION], [DRIVE] in addition to V1's [STATE]) close the feedback loop with gated action execution and clamped drive overrides.

The dominant risks are behavioral, not technical. The stack is settled and well-proven. The architecture patterns are established in V1 and need incremental extension, not redesign. The danger is in the interplay between the LLM's narrative tendencies and the simulation's intended dynamics: the LLM will smooth urgency, resolve tension narratively without bio-state justification, and produce uniform emotional register regardless of drive intensity unless the prompt translation layer actively prevents it. These risks — drives that pressure without consequences, reward signal pollution, personality as decoration — are all recoverable via prompt engineering and parameter tuning, but they are easiest to catch early if each phase ends with explicit behavioral validation tests at drive extremes.

## Key Findings

### Recommended Stack

The V1 stack carries forward with minor version bumps and one important removal. Go 1.24.2 (already in use), `modernc.org/sqlite@v1.46.1` (CGO-free, no alternative), and `github.com/anthropics/anthropic-sdk-go@v1.24.0` (adds `ModelClaudeSonnet4_5_20250929` constant) are the three core dependencies. `golang.org/x/exp/slices` must be removed — the stdlib `slices` package (Go 1.21+) replaces it. The motivation/reward system has no external library: no Go RL library targets this domain correctly, and the formulas are plain float64 arithmetic (`drive = f(bio_var, personality_factor)`). TUI and WebSocket dependencies (bubbletea, nhooyr.io/websocket) are deferred — not part of V2 core.

**Core technologies:**
- Go 1.24.2: Application language — stable, no change needed, Swiss table maps improve state iteration, stdlib `slices` replaces `golang.org/x/exp/slices`
- `modernc.org/sqlite@v1.46.1`: Persistence — only viable CGO-free SQLite option; no breaking changes from V1's v1.45.0
- `anthropic-sdk-go@v1.24.0`: LLM integration — official SDK, API surface stable, adds newer model constants
- `google/uuid@v1.6.0`: Episodic memory ID generation — standard, no alternatives needed
- `math/rand/v2` (stdlib): Bio state noise — available since Go 1.22, replaces `golang.org/x/exp/rand`

**API pattern note:** Use `ModelClaudeHaiku4_5` for consciousness tick-level calls (high frequency, cost-sensitive) and `ModelClaudeSonnet4_5` for the reviewer (low frequency, needs interpretive depth). Temperature via `param.NewOpt(0.9)`. Vary temperature with drive intensity as a runtime concern — higher drives warrant higher temperature ceilings.

### Expected Features

V2's feature set inverts V1's failures. The three tests for aliveness — unprompted wanting, visible frustration when blocked, and occasional surprise — all require the drive system to be genuinely functional, not decorative. Features are organized into an MVP that validates the core hypothesis and a V2.1 that refines it once baseline behavior is observed.

**Must have (table stakes for V2 launch):**
- Drive/motivation system (5 core drives: energy, social connection, stimulation/novelty, safety, identity coherence) — without this V2 is V1
- Bio degradation for 8 reduced variables — creates stakes through decline, not just homeostasis
- Drive state to phenomenological translation — drive intensities become felt experience, never raw numbers in prompts
- Bidirectional feedback loop with strong pulses (absolute, not dt-scaled) — V1's loop existed but was too weak
- Drive-weighted spontaneous thought queue — spontaneous thoughts skewed by current drive intensities
- Structured LLM output annotation extended with `[ACTION]` and `[DRIVE]` tags — extends V1's `[STATE]` protocol
- 7 personality factors (replacing Big Five) — stress sensitivity, energy resilience, curiosity, self-observation, patience/frustration tolerance, risk aversion, social factor
- SQLite persistence for all state — required for identity continuity across sessions
- Psychologist reviewer at 3-minute tick rate — circuit-breaker for runaway loops, now with motivation state in its context
- Scenario injection with explicit bio effects — environment creates concrete drive conditions
- CLI with BIO / DRIVES / MIND / REVIEWER layer-tagged output

**Should have (add in V2.1 after core is validated):**
- Identity erosion under isolation/degradation — requires baseline session data to calibrate
- Drive frustration → behavioral drift (seeking → demanding → collapsed phases) — phase transitions need observed behavior to tune
- Goal formation (spontaneous forward-looking wants from drive thresholds) — drives must be stable before layering goals
- LLM drive modulation override mechanism — observable as deviation from expected drive-driven behavior
- Satisfaction events with proportional biochemical reward pulses — refine magnitudes after watching system response

**Defer to V3:**
- Web dashboard / WebSocket server — not needed to validate core hypothesis
- Multi-session identity arc with long-term pattern tracking
- Scenario scripting / narrative engine

**Explicitly out of scope (NEVER):**
- Circadian rhythm system — adds bio-realism without motivational richness; inject as scenario context if needed
- 20-variable biological model — V1 proved complexity without proportional behavioral value
- Multi-agent social interaction — the operator IS the social relationship

### Architecture Approach

V2 inserts one new layer — `motivation` — between `biology` and `consciousness` in the sequential tick pipeline, and adds one new feedback path — `[ACTION]` gated execution — from consciousness back to biology. Everything else adapts from V1 rather than replacing it. The main loop remains a single goroutine with sequential tick steps (biology → motivation → consciousness → feedback); the input reader and reviewer remain on independent goroutines. No new goroutines are introduced.

The `motivation` package is a pure-function processor: `Compute(bio biology.State, chronic ChronicState) MotivationState`. This keeps the boundary clean — motivation reads bio, produces goal context and drive urgencies, never writes to bio. Bio changes from actions flow through `[]biology.StateChange` applied in the loop, keeping all state mutation auditable. The LLM receives motivation state as phenomenological descriptions via `PromptBuilder`, never as numerical parameters. Three tag types in `FeedbackParser` close the loop: `[STATE]` (retained from V1), `[ACTION]` (gated execution), `[DRIVE]` (clamped override — LLM can suppress drive perception by at most 50% of the raw bio-derived value).

**Major components:**
1. `biology` — 8-10 vars, decay, thresholds, bio_damage accumulation; slimmed from 76 to ~30 interaction rules
2. `motivation` — pure-function drive computation, personality multipliers, goal selection, identity erosion tracking
3. `consciousness` — Engine, PromptBuilder (extended), FeedbackParser (multi-tag), SalienceCalculator, ThoughtQueue; adapted from V1
4. `memory` — SQLiteStore extended with motivation history and drive log tables; `ChronicState` persisted across sessions
5. `simulation.Loop` — new tick order: drain input → biology → motivation → consciousness → feedback; action execution added
6. `reviewer` — Psychologist meta-observer, extended prompt with motivation state and trajectory prediction

**Recommended build order:** `biology` → `motivation` → `consciousness/feedback` (multi-tag parser) → `consciousness/prompt` (motivation sections) → `simulation/loop` (new tick order) → `memory/sqlite` (schema extension) → `reviewer` extension

### Critical Pitfalls

1. **Drives that pressure without behavioral consequences** — The LLM treats drive state as context to acknowledge analytically, not pressure to act on. Prevention: translate drive magnitudes into behavioral register language ("you cannot stop thinking about food — the thought keeps intruding") not parameter language ("hunger: 0.8"). Validate by running at drive=0.9 for extended time and checking whether LLM response register actually shifts. If it does not, rework the prompt translation layer before proceeding.

2. **Reward signal pollution (LLM resolves tension narratively)** — LLMs resolve narrative tension by default; the LLM may say "I feel better" without anything biological changing, and if the feedback loop parses this as satisfaction, drives drop without justification. Prevention: drive levels must decrease only via bio rules and environmental inputs, never via LLM narrative claims. The structured annotation path covers arousal/valence; drive satisfaction requires a strict separate path. Write an explicit test: confirm hunger drive does not decrease after a food-related thought with no bio input.

3. **Personality as decoration (the V1 repeat)** — Personality factors computed as multipliers don't constrain LLM behavioral output if they only appear as numbers or mild descriptors in the prompt. V1's Big Five failed exactly this way. Prevention: each personality factor must appear as a concrete behavioral tendency in the system prompt ("you cannot let an unexplained thing go"). Additionally, personality must determine which spontaneous thought categories fire most — this creates behavioral personality differences independently of LLM prompt compliance.

4. **Homeostasis prevents spirals** — Fast-path homeostasis (cortisol half-life) recovers bio state faster than slow-path degradation accumulates it. Prevention: slow-path degradation rates must exceed recovery rates when needs go unmet. Distinguish fast-path (short-term, keeps things from going infinite) from slow-path (sustained accumulation that builds urgency). Validate by running unattended for 10 minutes and confirming degradation accumulates rather than resetting.

5. **LLM output parsing brittleness (V1 ADR-003 lesson revisited)** — Format drift increases over long sessions; the LLM omits, malforms, or extends structured tags. Prevention: defensive parsing with explicit fallbacks to prior known-good state (never zero-defaults); every parse failure visible in logs; exhaustive unit tests for malformed inputs. The `[ACTION]` and `[DRIVE]` tags add two new parsing surfaces that need the same treatment as `[STATE]`.

## Implications for Roadmap

Based on research, the build order follows the dependency chain in the feature graph: bio must exist before drives can be computed, drives must be computed before the motivation layer is integrated, and the consciousness layer can only be extended once the motivation context it receives is defined. Each phase should end with a behavioral validation test at drive extremes — not just compilation and unit tests — to catch the LLM behavioral pitfalls early.

### Phase 1: Biological Foundation (Slim)

**Rationale:** Everything else depends on bio state. Start by slimming V1's 20-variable model to the 8–10 variables that have direct motivational relevance. Remove variables that don't connect to at least one drive. Add `bio_damage` accumulation as a distinct degradation path. This phase has no LLM dependency and is fully testable in isolation.

**Delivers:** A `biology` package with 8-10 vars, decay, circadian (if kept minimal), thresholds, and the `bio_damage` accumulation path. Slimmed interaction rules (~30 vs 76).

**Addresses:** "Bio degradation (8 variables)" from FEATURES.md; "homeostasis vs. slow-path degradation" distinction from PITFALLS.md.

**Avoids:** Adding variables that don't connect to drives. Run the simulation unattended for 10+ minutes without LLM and verify slow-path degradation accumulates.

**Research flag:** Standard patterns — V1 biology is proven, this is adaptation not invention. No deeper research needed.

### Phase 2: Motivation Layer

**Rationale:** The motivation layer is the structural core of V2 and has no LLM dependency. Building it as pure functions before wiring it to consciousness allows full unit test coverage. Drive formulas, personality multipliers, goal selection, and identity erosion are all testable with mock bio state.

**Delivers:** `motivation` package — `Processor.Compute()` pure function, 5 core drive formulas, 7 personality factor multipliers, goal selection, `ChronicState` struct for session accumulation, identity erosion tracking.

**Addresses:** "Drive/motivation system (5 core drives)" and "7 personality factors" from FEATURES.md; "personality as decoration" from PITFALLS.md (personality must change thought queue priorities, testable here).

**Avoids:** Applying personality multipliers in multiple places (apply once, in motivation processor); treating drive overrides as ground truth (store separately as `DrivePerception`).

**Research flag:** Standard patterns — pure function processor, no novel integration concerns. No deeper research needed.

### Phase 3: Prompt Translation and Consciousness Extension

**Rationale:** Once drive state exists, the translation layer from drive intensities to phenomenological language is the highest-risk surface — this is where the LLM behavioral pitfalls live. Build this phase explicitly with behavioral validation: run at drive extremes and confirm response register shifts. The multi-tag feedback parser extends V1's proven `[STATE]` parser.

**Delivers:** Extended `consciousness/prompt.go` (motivation state and goal context sections with phenomenological language); extended `consciousness/feedback.go` (multi-tag parser for `[STATE]`, `[ACTION]`, `[DRIVE]`); `consciousness/action.go` (action tag type and validation).

**Addresses:** "Drive state to phenomenological translation" and "structured LLM output annotation" from FEATURES.md; "drives without behavioral pressure" and "LLM parsing brittleness" from PITFALLS.md.

**Avoids:** Raw drive numbers in prompts (anti-pattern from ARCHITECTURE.md). Build exhaustive parser unit tests for malformed inputs before integration.

**Research flag:** NEEDS attention — the prompt translation layer is where V1 failed and where LLM behavioral validation is required. Allocate time for manual testing at personality and drive extremes.

### Phase 4: Simulation Loop Integration (New Tick Order)

**Rationale:** The loop is the integration hub — wiring bio → motivation → consciousness → feedback with action execution and drive override application. This is the most complex phase because it combines all prior phases. Build order from ARCHITECTURE.md confirms this should come after all component packages are independently tested.

**Delivers:** `simulation/loop.go` with new tick order (drain input → bio → motivation → consciousness → feedback); gated action execution with `environment.Allows()` check; drive override application to `ChronicState`; DRIVES layer output added to display.

**Addresses:** "Bidirectional feedback loop with strong pulses" and "drive-weighted spontaneous thought queue" from FEATURES.md; "action loop cooldown" and "spontaneous thought starvation" from PITFALLS.md.

**Avoids:** Motivation writing directly to biology (return `[]biology.StateChange`, apply through loop). Apply all bio changes at end of tick, not mid-tick (integration gotcha from PITFALLS.md).

**Research flag:** Needs careful integration testing — this is where silent dt=0 bugs and feedback loop coupling errors surface. Run with dt=0 and dt=large on all feedback paths explicitly.

### Phase 5: Persistence Extension (SQLite Schema)

**Rationale:** Persistence is required for identity continuity across sessions and for identity erosion to be visible over time. The SQLite schema needs motivation tables and `ChronicState` serialization. V1's Store interface extends cleanly; this is lower-risk than integration phases.

**Delivers:** Extended `memory/sqlite.go` with motivation history and drive log tables; `ChronicState` persisted and recovered across sessions; atomic persistence of bio state and identity core in the same transaction (integration gotcha from PITFALLS.md).

**Addresses:** "Persistent identity across sessions" and (foundation for) "identity erosion" from FEATURES.md; "SQLite atomic persistence" gotcha from PITFALLS.md.

**Avoids:** Persisting bio state and identity core in separate transactions (recovery mismatch risk).

**Research flag:** Standard patterns — SQLite schema extension, well-understood. No deeper research needed.

### Phase 6: Reviewer Extension and Configuration

**Rationale:** The reviewer is observational — it doesn't block any other functionality. Extending it with motivation context and trajectory prediction is the last step because it requires all other layers to be stable. Configuration struct for all behavioral parameters (drive rates, degradation slopes, feedback multipliers) should be formalized in this phase, ensuring every tunable value is reachable without code changes.

**Delivers:** Extended `reviewer` package with motivation state and drive trajectory in its prompt; reviewer emits identity-consistency assessments (structured, not raw LLM text); configuration struct covering all drive, decay, and feedback parameters with sensible defaults.

**Addresses:** "Psychologist reviewer with interpretive authority" and "scenario injection" from FEATURES.md; "reviewer circularity" and "tuning parameters buried in code" from PITFALLS.md.

**Avoids:** Reviewer output becoming ground truth for identity updates (describe observed patterns, not prescribe behavior; update identity core from behavioral patterns only).

**Research flag:** Standard patterns for the reviewer. Configuration struct design is straightforward. No deeper research needed.

### Phase Ordering Rationale

- The bio → motivation → consciousness dependency chain is strict: each layer needs the output of the prior layer defined before it can be built or tested
- Motivation as a pure function (Phase 2) enables full unit testing before any LLM cost is incurred
- The prompt translation layer (Phase 3) is the highest-risk surface and is isolated to its own phase so it can be validated behaviorally before loop integration compounds the complexity
- Loop integration (Phase 4) is deliberately the last "hard" phase — all components are pre-tested before they're assembled under the tick cycle
- Persistence and reviewer (Phases 5-6) are lower-risk extensions that don't block the core simulation functioning

### Research Flags

Phases needing behavioral validation (not just code research):
- **Phase 3 (Prompt Translation):** LLM behavioral testing at drive extremes. Cannot be validated with unit tests alone — requires running the simulation and manually checking whether response register shifts with drive intensity. This is where V1 failed and where V2 must not.
- **Phase 4 (Loop Integration):** Integration testing with dt=0 edge cases; spontaneous thought distribution testing; feedback path auditing.

Phases with well-established patterns (standard implementation):
- **Phase 1 (Biology):** V1 code is source of truth; this is reduction and adaptation
- **Phase 2 (Motivation):** Pure functions, full unit test coverage possible
- **Phase 5 (Persistence):** SQLite schema extension; V1 Store interface extends cleanly
- **Phase 6 (Reviewer/Config):** Observational layer; configuration is data, not architecture

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | All versions verified against pkg.go.dev. API patterns confirmed against V1 working code. No open questions. |
| Features | HIGH | Grounded in V1 retrospective (directly observed failures), cognitive science foundations (SDT, appraisal theory), and advisory consultant perspectives. The feature prioritization reflects tested reasoning, not speculation. |
| Architecture | HIGH | V1 codebase analyzed in full. The new `motivation` package design is derived from well-understood pure-function patterns. Build order confirmed against feature dependency graph. Integration point boundaries are explicit. |
| Pitfalls | MEDIUM | V1 pitfalls (Pitfalls 1-6) are HIGH confidence — directly observed in V1. Novel hybrid architecture risks (LLM drive override manipulation, identity erosion runaway, action loop cooldowns) are MEDIUM — reasoned from first principles, plausible but not observed. |

**Overall confidence:** HIGH for technical execution. MEDIUM for LLM behavioral outcomes (inherently non-deterministic, validated only through runtime testing).

### Gaps to Address

- **Phenomenological translation language:** The exact phrasing that reliably shifts LLM response register at high drive intensities is not known until tested. Budget iteration time in Phase 3. The architecture is right; the prompt wording requires empirical validation.
- **Drive decay and recovery rate calibration:** Bio degradation rates are specified as "tunable" but initial values are not calibrated. Phase 1 should produce initial rate estimates from the target behavior (10 minutes of neglect → visible degradation) but these will need adjustment in Phase 4 integration testing.
- **Action cooldown durations:** The action execution gate needs per-action cooldown values (e.g., "eat" cannot fire again for N seconds). These values depend on the bio variable ranges and tick rate. Not a design gap, but a calibration gap to address in Phase 4.
- **Identity erosion calibration:** How fast erosion accumulates, and at what thresholds it changes prompt language, requires observation from actual V2 runs. The V2.1 identity erosion feature depends on baseline data from the V2 MVP.

## Sources

### Primary (HIGH confidence)
- V1 codebase at `/home/marczahn/dev/person/v1/` — direct source of proven patterns and confirmed failure modes
- pkg.go.dev — version verification for all dependencies (Feb 18, 2026)
- go.dev/blog/go1.24 — Go 1.24 feature list
- `.planning/PROJECT.md` — authoritative V2 requirements and constraints

### Secondary (MEDIUM confidence)
- `v1/docs/adr/ADR-001`, `ADR-003` — thought continuity and structured feedback patterns
- `v1/docs/advisory/biologist.md`, `philosopher.md`, `psychologist.md` — domain expert perspectives on bio modeling, consciousness architecture, and personality
- `v1/docs/plan/decisions.md` — V1 design decisions and retrospective
- github.com/anthropics/anthropic-sdk-go README and CHANGELOG — API patterns and breaking change confirmation

### Tertiary (LOW confidence, needs runtime validation)
- Phenomenological drive translation language — no prior art; must be validated empirically in Phase 3
- Drive escalation and decay rate initial values — derived from target behavior, not calibrated against observation
- Novel hybrid pitfalls (LLM drive override manipulation, action loop dynamics) — reasoned from first principles

---
*Research completed: 2026-02-18*
*Ready for roadmap: yes*
