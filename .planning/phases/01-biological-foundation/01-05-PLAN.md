---
phase: 01-biological-foundation
plan: "05"
type: execute
wave: 3
depends_on:
  - "01-02"
  - "01-03"
files_modified:
  - v2/bio/noise.go
  - v2/bio/engine.go
autonomous: true
requirements:
  - BIO-05

must_haves:
  truths:
    - "Engine.Tick(s, dt) applies the full pipeline: decay → interactions → noise → clamp → thresholds+cascades → clamp again"
    - "Noise adds non-deterministic variation to every variable each tick (different state every tick even at dt=0 decay)"
    - "Noise is applied BEFORE clamp — noise-induced out-of-range values are corrected, not accumulated"
    - "TickResult contains Deltas from decay/interactions and ThresholdEvents from threshold evaluation"
    - "Engine is constructed with Config; NewEngine(Config) returns *Engine"
  artifacts:
    - path: "v2/bio/noise.go"
      provides: "Gaussian noise application using math/rand.NormFloat64 scaled by sqrt(dt)"
      exports: ["ApplyNoise"]
    - path: "v2/bio/engine.go"
      provides: "Engine struct wiring the full tick pipeline"
      exports: ["Engine", "Config", "TickResult", "NewEngine"]
  key_links:
    - from: "v2/bio/engine.go"
      to: "v2/bio/decay.go"
      via: "Engine.Tick calls ApplyDecay"
      pattern: "ApplyDecay\\(s,"
    - from: "v2/bio/engine.go"
      to: "v2/bio/interactions.go"
      via: "Engine.Tick calls ApplyInteractions"
      pattern: "ApplyInteractions\\(s,"
    - from: "v2/bio/engine.go"
      to: "v2/bio/noise.go"
      via: "Engine.Tick calls ApplyNoise"
      pattern: "ApplyNoise\\(s,"
    - from: "v2/bio/engine.go"
      to: "v2/bio/thresholds.go"
      via: "Engine.Tick calls EvaluateThresholds then ApplyThresholdCascades"
      pattern: "EvaluateThresholds\\(s,"
---

<objective>
Implement Gaussian noise application and the Engine that wires the full tick pipeline into a single deterministic-interface entrypoint.

Purpose: Noise prevents stagnation (BIO-05). The Engine is the single interface the rest of the system uses — it encapsulates the exact execution order that prevents the pitfalls identified in research (noise before clamp, cascades after clamp, dt cap, snapshot-based rule evaluation).
Output: v2/bio/noise.go, v2/bio/engine.go
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-biological-foundation/01-CONTEXT.md
@.planning/phases/01-biological-foundation/01-RESEARCH.md
@.planning/phases/01-biological-foundation/01-01-SUMMARY.md
@.planning/phases/01-biological-foundation/01-02-SUMMARY.md
@.planning/phases/01-biological-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Gaussian noise</name>
  <files>v2/bio/noise.go</files>
  <action>
Create `v2/bio/noise.go` with package `bio`. Implements BIO-05: apply Gaussian noise to each bio variable each tick.

**NoiseConfig:**
```go
package bio

import (
    "math"
    "math/rand"
)

// NoiseConfig controls Gaussian noise parameters.
type NoiseConfig struct {
    // Sigma is the base noise standard deviation per second.
    // Noise per tick scales with sqrt(dt) for Brownian consistency.
    // Recommended: 0.002 (0.2% of range per second at 1x).
    Sigma float64
}

func DefaultNoiseConfig() NoiseConfig {
    return NoiseConfig{Sigma: 0.002}
}
```

**ApplyNoise:**
```go
// ApplyNoise adds Gaussian noise to all bio variables, scaled by sqrt(dt) for
// Brownian consistency (same total noise variance regardless of tick rate).
// BodyTemp receives smaller noise (0.1x sigma) since it has a narrower functional range.
// Clamp is NOT called here — caller must call clampAll after noise to absorb boundary violations.
// Noise changes are not individually tracked (too granular for delta logging).
func ApplyNoise(s *State, rng *rand.Rand, cfg NoiseConfig, dt float64) {
    if dt <= 0 {
        return
    }
    sigma := cfg.Sigma * math.Sqrt(dt)
    s.Energy           += rng.NormFloat64() * sigma
    s.Stress           += rng.NormFloat64() * sigma
    s.CognitiveCapacity += rng.NormFloat64() * sigma
    s.Mood             += rng.NormFloat64() * sigma
    s.PhysicalTension  += rng.NormFloat64() * sigma
    s.Hunger           += rng.NormFloat64() * sigma
    s.SocialDeficit    += rng.NormFloat64() * sigma
    // BodyTemp: 0.1x sigma because it's a 18°C range, not 0-1
    s.BodyTemp         += rng.NormFloat64() * sigma * 0.1
}
```

Use a local `*rand.Rand` (passed as parameter) — NOT the global `rand.Float64()`. This enables deterministic seeding in tests by passing a seeded rng.
  </action>
  <verify>Run `cd v2 && go build ./bio/...`. Verify ApplyNoise is exported. Verify it does NOT call clampAll. Verify BodyTemp gets 0.1x sigma multiplier.</verify>
  <done>noise.go compiles; ApplyNoise exported; takes *rand.Rand parameter (not global rand); dt<=0 early return; BodyTemp gets smaller noise; no clamping inside this function.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Engine — the tick pipeline</name>
  <files>v2/bio/engine.go</files>
  <action>
Create `v2/bio/engine.go` with package `bio`. The Engine wires the complete tick pipeline.

**Config (combined config for all sub-components):**
```go
package bio

import (
    "math/rand"
    "time"
)

// Config holds all engine configuration.
type Config struct {
    Decay      DecayConfig
    Noise      NoiseConfig
    Thresholds ThresholdConfig
}

// DefaultConfig returns development-friendly defaults:
// 5x decay speed, noise sigma=0.002, terminal states disabled.
func DefaultConfig() Config {
    return Config{
        Decay:      DefaultDecayConfig(),
        Noise:      DefaultNoiseConfig(),
        Thresholds: DefaultThresholdConfig(),
    }
}
```

**TickResult:**
```go
// TickResult holds the output of one Engine.Tick call.
type TickResult struct {
    Deltas     []Delta          // changes from decay and interactions (not noise)
    Thresholds []ThresholdEvent // threshold crossings detected this tick
}
```

**Engine:**
```go
// Engine runs the bio simulation tick pipeline.
// Create with NewEngine; call Tick each simulation step.
type Engine struct {
    config Config
    rng    *rand.Rand
}

// NewEngine creates an Engine with the given config and a random seed.
func NewEngine(cfg Config) *Engine {
    return &Engine{
        config: cfg,
        rng:    rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

// NewEngineWithSeed creates a deterministic Engine for testing.
func NewEngineWithSeed(cfg Config, seed int64) *Engine {
    return &Engine{
        config: cfg,
        rng:    rand.New(rand.NewSource(seed)),
    }
}
```

**Tick — the full pipeline:**
```go
// Tick advances the bio state by dt seconds. Pipeline order is CRITICAL:
//   1. Apply linear decay (autonomous degradation)
//   2. Apply interaction rules (cross-variable effects, snapshot-based)
//   3. Apply Gaussian noise (stochastic variation)
//   4. Clamp all variables to valid ranges
//   5. Evaluate thresholds → apply cascade effects → clamp again
// Clamp is called twice: once after noise, once after threshold cascades.
// This ensures cascades cannot push variables out of range.
func (e *Engine) Tick(s *State, dt float64) TickResult {
    var result TickResult

    // 1. Decay
    ApplyDecay(s, e.config.Decay, dt)

    // 2. Interactions (snapshot-based, returns deltas for logging)
    result.Deltas = ApplyInteractions(s, dt)

    // 3. Noise
    ApplyNoise(s, e.rng, e.config.Noise, dt)

    // 4. First clamp — absorbs decay, interaction, and noise out-of-range values
    clampAll(s)

    // 5. Threshold evaluation → cascade application → second clamp
    events := EvaluateThresholds(s, e.config.Thresholds, dt)
    result.Thresholds = events
    ApplyThresholdCascades(s, events)
    clampAll(s) // cascade effects must also be clamped

    s.UpdatedAt = time.Now()
    return result
}
```

Note the intentional double-clamp. The first clamp corrects noise/decay/interaction overruns. The second clamp corrects threshold cascade overruns. This is not redundant — it's the correct guard against the pitfall documented in RESEARCH.md.
  </action>
  <verify>Run `cd v2 && go build ./bio/...`. Run `cd v2 && go vet ./bio/...`. Verify Engine.Tick calls the 5 pipeline steps in order (ApplyDecay → ApplyInteractions → ApplyNoise → clampAll → EvaluateThresholds/ApplyThresholdCascades → clampAll). Check NewEngineWithSeed exists for deterministic testing.</verify>
  <done>engine.go compiles; NewEngine and NewEngineWithSeed exported; Tick pipeline has double-clamp; TickResult has Deltas and Thresholds; Config struct embeds DecayConfig, NoiseConfig, ThresholdConfig; DefaultConfig returns 5x decay multiplier.</done>
</task>

</tasks>

<verification>
- `cd v2 && go build ./bio/...` exits 0
- `cd v2 && go vet ./bio/...` exits 0
- Engine.Tick pipeline order: decay → interactions → noise → clampAll → thresholds → cascades → clampAll
- ApplyNoise uses *rand.Rand parameter (local, not global)
- NewEngineWithSeed exists with seed int64 parameter
- TickResult exported with Deltas []Delta and Thresholds []ThresholdEvent
- DefaultConfig uses DecayMultiplier=5.0 (development speed)
</verification>

<success_criteria>
noise.go and engine.go compile; full tick pipeline wired in correct order; double-clamp pattern implemented; deterministic seed constructor available for tests; entire v2/bio package builds cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/01-biological-foundation/01-05-SUMMARY.md`
</output>
