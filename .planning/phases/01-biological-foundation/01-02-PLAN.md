---
phase: 01-biological-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - v2/bio/decay.go
  - v2/bio/interactions.go
autonomous: true
requirements:
  - BIO-03
  - BIO-04

must_haves:
  truths:
    - "After 600 ticks at dt=1.0, Energy has dropped by at least 0.2 from baseline 0.8"
    - "After 600 ticks at dt=1.0, Hunger has risen by at least 0.2 from baseline 0.1"
    - "Stress, PhysicalTension, and BodyTemp do NOT change from decay alone (no autonomous decay for them)"
    - "Interaction rules fire based on pre-tick state — no single-tick feedback explosion"
    - "High stress (>0.6) raises PhysicalTension within a tick; the rule is applied correctly"
  artifacts:
    - path: "v2/bio/decay.go"
      provides: "Linear decay for 5 autonomously degrading variables"
      exports: ["ApplyDecay", "DecayConfig"]
    - path: "v2/bio/interactions.go"
      provides: "22 data-driven interaction rules between bio variables"
      exports: ["ApplyInteractions", "Rule"]
  key_links:
    - from: "v2/bio/decay.go"
      to: "v2/bio/state.go"
      via: "modifies *State fields directly"
      pattern: "s\\.Energy\\s*-="
    - from: "v2/bio/interactions.go"
      to: "v2/bio/state.go"
      via: "Rule.Apply func reads pre-tick state, returns Delta applied to *State"
      pattern: "motivationRules"
---

<objective>
Implement the two autonomous bio change mechanisms: linear decay (5 variables drift toward degraded state each tick) and data-driven interaction rules (22 rules modeling cross-variable effects).

Purpose: These are the core pressure generators. Decay makes variables degrade over time without any action; interactions create compound spirals (hunger+stress→mood collapse) that create urgency in the motivation layer.
Output: v2/bio/decay.go, v2/bio/interactions.go
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-biological-foundation/01-CONTEXT.md
@.planning/phases/01-biological-foundation/01-RESEARCH.md
@.planning/phases/01-biological-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement linear decay</name>
  <files>v2/bio/decay.go</files>
  <action>
Create `v2/bio/decay.go` with package `bio`. Implements BIO-03 and BIO-04: autonomous degradation for 5 variables, no homeostasis.

**Critical distinction:** "No automatic homeostasis" means no variable auto-returns to baseline. BUT degradation toward degraded state IS autonomous. Only 5 variables degrade autonomously:
- Energy: drifts toward 0 (exhaustion)
- Hunger: rises toward 1 (starvation)
- CognitiveCapacity: drifts toward 0 (mental depletion)
- Mood: drifts toward 0 (dysphoria)
- SocialDeficit: rises toward 1 (isolation)

Variables with NO autonomous decay: Stress, PhysicalTension, BodyTemp — these only change from explicit causes (interactions, thresholds, external feedback).

**Decay rates (linear, per-second at multiplier=1.0):**
Calibrated for degradation visible within 3-5 minutes (180-300s). Target: 20% change from baseline within 4 minutes.
- energyDecayRate = 0.00067   // 0.8→0.6 in ~300s at 1x; 0.8→0.6 in ~60s at 5x
- hungerDecayRate = 0.00083   // 0.1→0.3 in ~240s at 1x
- cogCapDecayRate = 0.00050   // 1.0→0.8 in ~400s at 1x
- moodDecayRate   = 0.00033   // 0.5→0.3 in ~600s at 1x (mood drifts slower)
- socialDecayRate = 0.00033   // 0.0→0.2 in ~600s at 1x (social isolation is slow)

**DecayConfig and ApplyDecay:**
```go
package bio

// DecayConfig holds the multiplier for autonomous decay rates.
// DecayMultiplier=1.0 is normal speed; 5.0 is fast development mode (5x faster degradation).
// HomeostasisEnabled=false is the V2 default — no variable auto-returns to baseline.
type DecayConfig struct {
    DecayMultiplier     float64
    HomeostasisEnabled  bool // reserved for future use; always false in V2
}

// DefaultDecayConfig returns the development-friendly default:
// 5x speed so degradation is visible within ~1 minute.
func DefaultDecayConfig() DecayConfig {
    return DecayConfig{
        DecayMultiplier:    5.0,
        HomeostasisEnabled: false,
    }
}

// ApplyDecay applies autonomous linear decay to s in-place for elapsed dt seconds.
// Only 5 variables decay autonomously (BIO-03).
// Clamp is NOT called here — caller must call clampAll after all mutations.
func ApplyDecay(s *State, cfg DecayConfig, dt float64) {
    rate := cfg.DecayMultiplier * dt
    s.Energy           -= energyDecayRate * rate
    s.Hunger           += hungerDecayRate * rate
    s.CognitiveCapacity -= cogCapDecayRate * rate
    s.Mood             -= moodDecayRate   * rate
    s.SocialDeficit    += socialDecayRate * rate
    // Stress, PhysicalTension, BodyTemp: no autonomous decay
}
```

Define decay rate constants as unexported package-level vars (not buried in function body) so tests can reference them for calibration assertions.

**dt cap:** In ApplyDecay, cap dt at 60.0 seconds maximum to prevent pause-recovery explosions (V1 used 300s; V2 with fast decay needs tighter cap). Apply the cap inside ApplyDecay:
```go
if dt > 60.0 { dt = 60.0 }
```
  </action>
  <verify>Run `cd v2 && go build ./bio/...` — must compile. Check that `ApplyDecay` modifies exactly 5 fields: Energy (-=), Hunger (+=), CognitiveCapacity (-=), Mood (-=), SocialDeficit (+=). Stress, PhysicalTension, BodyTemp must NOT appear in the decay function body.</verify>
  <done>decay.go compiles; ApplyDecay exists; 5 decay variables declared with rates; dt cap at 60s implemented; Stress/PhysicalTension/BodyTemp not touched by decay.</done>
</task>

<task type="auto">
  <name>Task 2: Implement data-driven interaction rules</name>
  <files>v2/bio/interactions.go</files>
  <action>
Create `v2/bio/interactions.go` with package `bio`. Implements 22 motivation-relevant interaction rules between bio variables.

**Key design constraint:** Rules must be evaluated against pre-tick state, not the state as modified by earlier rules in the same tick. This prevents single-tick feedback explosions. Pattern: capture a snapshot of the state before applying any rules, evaluate conditions against the snapshot, accumulate all deltas, then apply all deltas to the real state at the end.

**Delta type:**
```go
// Delta represents a change to a specific bio state field.
type Delta struct {
    Field  string  // field name for logging
    Amount float64 // the change amount (positive or negative)
}
```

**Rule type:**
```go
// Rule is a data-driven interaction rule between bio variables.
type Rule struct {
    Name      string
    Condition func(s *State) bool
    Apply     func(s *State, dt float64) Delta
}
```

**ApplyInteractions evaluates all 22 rules and applies their combined deltas:**
```go
// ApplyInteractions evaluates all motivation rules against the pre-tick state snapshot
// and applies the combined deltas to s. Clamp is not called here.
// Single-pass evaluation: all conditions read from snapshot, not from post-rule state.
func ApplyInteractions(s *State, dt float64) []Delta {
    snap := *s // snapshot pre-tick state for condition evaluation
    var deltas []Delta
    for _, rule := range motivationRules {
        if rule.Condition(&snap) {
            d := rule.Apply(&snap, dt)
            deltas = append(deltas, d)
            // Apply to real state immediately (but conditions already evaluated from snap)
            applyDelta(s, d)
        }
    }
    return deltas
}
```

**applyDelta helper:**
```go
func applyDelta(s *State, d Delta) {
    switch d.Field {
    case "energy":           s.Energy           += d.Amount
    case "stress":           s.Stress           += d.Amount
    case "cognitive_capacity": s.CognitiveCapacity += d.Amount
    case "mood":             s.Mood             += d.Amount
    case "physical_tension": s.PhysicalTension  += d.Amount
    case "hunger":           s.Hunger           += d.Amount
    case "social_deficit":   s.SocialDeficit    += d.Amount
    case "body_temp":        s.BodyTemp         += d.Amount
    }
}
```

**The 22 motivationRules (implement as package-level var):**
Use the exact rules from RESEARCH.md, adapting field names to use CognitiveCapacity (not CognitiveLoad):

| # | Condition | Target | Effect |
|---|-----------|--------|--------|
| 1 | Stress > 0.6 | PhysicalTension | += snap.Stress * 0.3 * dt |
| 2 | Stress > 0.5 | CognitiveCapacity | -= snap.Stress * 0.2 * dt (stress depletes capacity) |
| 3 | Stress > 0.7 | Mood | -= 0.002 * dt |
| 4 | Hunger > 0.7 | Stress | += 0.001 * dt |
| 5 | Hunger > 0.8 | CognitiveCapacity | -= 0.002 * dt |
| 6 | Energy < 0.3 | Mood | -= 0.001 * dt |
| 7 | Energy < 0.2 | Stress | += 0.002 * dt |
| 8 | Energy < 0.2 | CognitiveCapacity | -= 0.002 * dt |
| 9 | PhysicalTension > 0.7 | Stress | += 0.001 * dt |
| 10 | PhysicalTension > 0.6 | Mood | -= 0.001 * dt |
| 11 | CognitiveCapacity < 0.2 (inverted from "load > 0.8") | Stress | += 0.002 * dt |
| 12 | CognitiveCapacity < 0.3 | Mood | -= 0.001 * dt |
| 13 | Mood < 0.2 | Stress | += 0.001 * dt |
| 14 | Mood < 0.2 | SocialDeficit | += 0.001 * dt |
| 15 | SocialDeficit > 0.7 | Mood | -= 0.001 * dt |
| 16 | SocialDeficit > 0.8 | Stress | += 0.001 * dt |
| 17 | BodyTemp < 35.5 | Stress | += (35.5-snap.BodyTemp)*0.01 * dt |
| 18 | BodyTemp < 35.5 | PhysicalTension | += (35.5-snap.BodyTemp)*0.05 * dt |
| 19 | BodyTemp > 38.5 | Stress | += (snap.BodyTemp-38.5)*0.01 * dt |
| 20 | BodyTemp > 38.5 | CognitiveCapacity | -= (snap.BodyTemp-38.5)*0.03 * dt |
| 21 | Energy < 0.4 && Hunger > 0.6 | Mood | -= 0.002 * dt |
| 22 | Stress > 0.8 && CognitiveCapacity < 0.3 | Mood | -= 0.003 * dt |

Important for rules 11 and 12: CognitiveCapacity is inverted from "CognitiveLoad" in research. High CogntiiveLoad = Low CognitiveCapacity. So rule 11 fires when CognitiveCapacity < 0.2 (equivalent to load > 0.8), and rule 12 fires when CognitiveCapacity < 0.3.

Each rule should have a descriptive Name string for logging/debugging.
  </action>
  <verify>Run `cd v2 && go build ./bio/...`. Grep for `len(motivationRules)` — should be 22. Each rule must have a non-empty Name field. Verify the snapshot pattern is used: `snap := *s` must appear in `ApplyInteractions` before any rule condition is evaluated.</verify>
  <done>interactions.go compiles; 22 rules defined; snapshot pattern implemented; ApplyInteractions returns []Delta; applyDelta handles all 8 field names.</done>
</task>

</tasks>

<verification>
- `cd v2 && go build ./bio/...` exits 0
- `cd v2 && go vet ./bio/...` exits 0
- `ApplyDecay` does not touch Stress, PhysicalTension, or BodyTemp
- `ApplyInteractions` uses `snap := *s` snapshot before evaluating conditions
- dt cap at 60.0 in ApplyDecay
- 22 rules in motivationRules
- CognitiveCapacity naming consistent throughout (not CognitiveLoad)
</verification>

<success_criteria>
decay.go and interactions.go compile; decay touches exactly 5 variables; 22 interaction rules with snapshot evaluation pattern; dt cap prevents pause-recovery explosions.
</success_criteria>

<output>
After completion, create `.planning/phases/01-biological-foundation/01-02-SUMMARY.md`
</output>
